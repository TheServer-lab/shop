<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Shopping Site â€” Final Deploy (Updated)</title>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<style>
  body{font-family:Arial,Helvetica,sans-serif;max-width:980px;margin:18px auto;background:#f7f7f8;color:#202020}
  header{display:flex;justify-content:space-between;align-items:center;padding:8px 0;border-bottom:1px solid #ddd;flex-wrap:wrap}
  h1{margin:0;font-size:20px}
  h2,h3{margin:12px 0 8px}
  .item{background:#fff;border:1px solid #e0e0e0;border-radius:8px;padding:12px;margin:10px 0;box-shadow:0 1px 2px rgba(0,0,0,0.03)}
  button{padding:6px 10px;border-radius:6px;border:1px solid #bdbdbd;background:#fafafa;cursor:pointer}
  button:disabled{opacity:0.5;cursor:not-allowed}
  #cartSection{margin-top:18px;padding:12px;background:#fff;border-radius:8px;border:1px solid #e6e6e6}
  .modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,0.5);z-index:200}
  .modal-content{background:#fff;padding:18px;border-radius:8px;width:420px;margin:6% auto}
  input,textarea,select{display:block;margin:8px 0;padding:8px;width:94%;box-sizing:border-box}
  #adminPanel{margin-top:20px;padding:12px;background:#fff;border-radius:8px;border:1px solid #e6e6e6}
  .adminItem{border-bottom:1px solid #f0f0f0;padding:6px 0;display:flex;justify-content:space-between;align-items:center}
  #statusBar{font-size:13px;color:#555}
  .status-ok{color:green}
  .status-bad{color:red}
  pre#adminLogView, pre#ordersView{white-space:pre-wrap;background:#f6f6f6;padding:8px;border-radius:6px;display:none;max-height:300px;overflow:auto}
  small.note{color:#666}
  .flex-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .muted{color:#666;font-size:90%}
  .order-row{margin:6px 0;padding:6px;border:1px solid #eee;border-radius:6px;background:#fff;display:flex;justify-content:space-between;align-items:center}
  .order-actions button{margin-left:6px}
  .badge{padding:2px 6px;border-radius:4px;font-size:12px}
  .badge-done{background:#e6ffed;color:#007a3a}
  .badge-deleted{background:#ffecec;color:#9a1c1c}
  .admin-controls button{margin-left:6px}
  .top-note{font-size:13px;color:#666;margin-top:6px}
  #cartList li{margin:6px 0}
</style>
</head>
<body>
<header>
  <div>
    <h1>ðŸ›’ Simple Shopping Site</h1>
    <div id="statusBar">Resolving server...</div>
    <div class="top-note">Tip: place <code>tunnel.txt</code> beside this page (same origin) to use a tunnel URL.</div>
  </div>
  <div id="userPanel">
    <span id="userInfo">Guest</span>
    <button id="loginBtn">Login / Register</button>
    <button id="adminLoginBtn">Admin Login</button>
    <button id="logoutBtn" style="display:none">Logout</button>
  </div>
</header>

<main>
  <h2>Products</h2>
  <div id="itemList"><small class="note">Loading itemsâ€¦</small></div>

  <section id="cartSection">
    <h3>Your Cart</h3>
    <ul id="cartList"></ul>
    <p id="cartTotal" class="muted">Total will be computed at checkout</p>
    <button id="placeOrderBtn">Place Order</button>
  </section>

  <section id="adminPanel" style="display:none;">
    <h3>Admin Panel</h3>
    <div id="adminUnlocked" style="display:none;">
      <h4>Add / Update Item</h4>
      <input id="itemId" placeholder="ID (leave blank to auto)">
      <input id="itemTitle" placeholder="Title">
      <input id="itemPrice" placeholder="Price (e.g. 199.99)">
      <input id="itemStock" placeholder="Stock (integer)">
      <textarea id="itemDesc" placeholder="Description"></textarea>
      <div class="flex-row">
        <button id="saveItemBtn">Save Item</button>
        <button id="clearEditBtn">Clear</button>
        <button id="viewLogsBtn">View Admin Log</button>
        <button id="viewOrdersBtn">View Orders</button>
        <select id="ordersFilter">
          <option value="all">All</option>
          <option value="pending">Pending</option>
          <option value="done">Done</option>
          <option value="deleted">Deleted</option>
        </select>
      </div>
      <h4 style="margin-top:12px">Existing Items</h4>
      <div id="adminItemList"></div>

      <h4 style="margin-top:14px">Admin Log</h4>
      <pre id="adminLogView"></pre>

      <h4 style="margin-top:14px">Orders</h4>
      <div id="ordersList"></div>
      <pre id="ordersView"></pre>
    </div>
  </section>
</main>

<!-- User modal -->
<div id="loginModal" class="modal">
  <div class="modal-content">
    <h3>Login / Register</h3>
    <input id="name" placeholder="Full name (for register)">
    <input id="phone" placeholder="Phone (digits only)">
    <input id="password" type="password" placeholder="Password">
    <div style="text-align:right;margin-top:8px">
      <button id="loginSubmit">Submit</button>
      <button id="closeModal">Close</button>
    </div>
  </div>
</div>

<!-- Admin modal -->
<div id="adminModal" class="modal">
  <div class="modal-content">
    <h3>Admin Login</h3>
    <input id="adminUser" placeholder="Admin username">
    <input id="adminPass" type="password" placeholder="Admin password">
    <div style="text-align:right;margin-top:8px">
      <button id="adminLoginSubmit">Login</button>
      <button id="closeAdminModal">Close</button>
    </div>
  </div>
</div>

<script>
/* Improved shop.html
   - Robust fetchFile fallback (tries /file/<path>?key=..., then direct URL baseUrl + '/' + path)
   - Cart shows product titles + computed total
   - Better getNextOrderNumber and safer upload handling
   - Keeps admin log and uploadFile endpoints intact
*/

// ==== CONFIG ====
let baseUrl = null;
const serverKey = "5duM4W8HZiQBSU4v"; // keep secret in server ideally
let currentUser = null;
let cart = {};           // { id: qty }
let adminUser = null;
let adminUnlocked = false;

// DOM refs
const statusBar = document.getElementById('statusBar');
const itemList = document.getElementById('itemList');
const cartList = document.getElementById('cartList');
const cartTotal = document.getElementById('cartTotal');

// helpers
function showStatus(text, ok){ statusBar.textContent = text; statusBar.className = ok ? "status-ok" : "status-bad"; }
function timeNow(){ const d=new Date(); const pad=n=>String(n).padStart(2,'0'); return `${d.getFullYear()}-${pad(d.getMonth()+1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`; }
function escapeHtml(s){ return String(s||'').replace(/[&<>"']/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

// ==== Server resolution ====
async function resolveServer(){
  try{
    const origin = (location.protocol === 'file:') ? null : location.origin;
    if(origin){
      const url = origin.replace(/\/$/,'') + '/tunnel.txt';
      const r = await fetch(url, {cache:"no-store"});
      if(r.ok){
        const text = (await r.text()).trim();
        if(text){
          try{ const u = new URL(text); return u.origin; } catch(e){ return text.replace(/\/$/,''); }
        }
      }
    }
  }catch(e){}
  return "http://localhost:8080";
}

// ==== low-level API helpers (room/file/files as in your server) ====
async function apiPost(room, data){
  try {
    const url = `${baseUrl}/room/${room}?key=${encodeURIComponent(serverKey)}`;
    const res = await fetch(url, { method:'POST', headers: {'Content-Type':'application/json'}, body: JSON.stringify(data) });
    if(!res.ok){ const txt = await res.text().catch(()=>''); console.error('apiPost failed', res.status, txt); return {ok:false, status:res.status, text:txt}; }
    let json = null; try{ json = await res.json(); }catch(e){ json=null; }
    return { ok:true, status:res.status, json };
  } catch(e){ console.error('apiPost error', e); return { ok:false, error:e }; }
}

async function apiGet(room){
  try {
    const url = `${baseUrl}/room/${room}?key=${encodeURIComponent(serverKey)}`;
    const res = await fetch(url);
    if(!res.ok) return {};
    const j = await res.json();
    return j.data || {};
  } catch(e){ console.error('apiGet error', e); return {}; }
}

// Try to fetch file through your /file/ endpoint first; fallback to direct static URL (baseUrl + '/' + path)
async function fetchFile(path){
  // path is something like "shopping-site/orders/order1.txt"
  // try server's /file/<encodedPath>?key=...
  try {
    const p1 = encodeURIComponent(path);
    const url1 = `${baseUrl}/file/${p1}?key=${encodeURIComponent(serverKey)}`;
    let res = await fetch(url1);
    if(res.ok) return res;
    // fallback: try direct static path
    const url2 = `${baseUrl.replace(/\/$/,'')}/${path.replace(/^\/+/,'')}`;
    res = await fetch(url2);
    if(res.ok) return res;
    // another fallback: try with "shopping-site/" prefix removed for older structure
    const last = path.split('/').pop();
    const url3 = `${baseUrl.replace(/\/$/,'')}/${last}`;
    res = await fetch(url3);
    return res; // return even if not ok for caller to inspect status
  } catch(e){
    console.error('fetchFile error', e);
    throw e;
  }
}

async function uploadFile(path, blob){
  // try /file/<encodedPath>?key=... with multipart form data
  try{
    const form = new FormData();
    form.append('file', blob, path.split('/').pop() || 'upload.txt');
    const p1 = encodeURIComponent(path);
    const url1 = `${baseUrl}/file/${p1}?key=${encodeURIComponent(serverKey)}`;
    let res = await fetch(url1, { method:'POST', body: form });
    if(res.ok) return res;
    // fallback: try PUT to direct path if supported (some servers may accept)
    try {
      const url2 = `${baseUrl.replace(/\/$/,'')}/${path.replace(/^\/+/,'')}`;
      res = await fetch(url2, { method:'PUT', body: blob, headers: { 'Content-Type':'text/plain' } });
      return res;
    } catch(e){}
    return res;
  } catch(e){
    console.error('uploadFile error', e);
    throw e;
  }
}

async function listFilesWithPrefix(prefix){
  // Try server endpoint /files?prefix=...
  try{
    const u = `${baseUrl}/files?key=${encodeURIComponent(serverKey)}&prefix=${encodeURIComponent(prefix)}`;
    const r = await fetch(u);
    if(r.ok){
      const j = await r.json();
      if(Array.isArray(j.files)) return j.files;
    }
  }catch(e){ console.warn('listFilesWithPrefix primary failed', e); }
  // Fallback: try an index file at prefix/index.json
  try{
    const idxUrl = `${baseUrl.replace(/\/$/,'')}/${prefix.replace(/\/$/,'')}/index.json`;
    const r2 = await fetch(idxUrl);
    if(r2.ok){
      const j2 = await r2.json();
      if(Array.isArray(j2)) return j2;
      if(Array.isArray(j2.files)) return j2.files;
    }
  }catch(e){}
  return [];
}

// ==== admin logging ====
async function logAdmin(action){
  if(!adminUser) return;
  const line = `[${timeNow()}] ${adminUser}: ${action}\n`;
  // append to admin_log.txt
  try{
    let existing = '';
    try {
      const r = await fetchFile('shopping-site/admin_log.txt');
      if(r && r.ok) existing = await r.text();
    } catch(e){}
    const blob = new Blob([existing + line], { type:'text/plain' });
    await uploadFile('shopping-site/admin_log.txt', blob);
  } catch(e){ console.error('logAdmin write failed', e); }
}

// ==== auth ====
async function loginOrRegister(){
  const name = document.getElementById("name").value.trim();
  const phone = document.getElementById("phone").value.trim();
  const pass = document.getElementById("password").value;
  if(!phone || !pass){ alert('Enter phone and password'); return; }
  let accounts = await apiGet('accounts');
  if(!accounts || typeof accounts !== 'object') accounts = {};
  if(!accounts[phone]){
    accounts[phone] = { name: name || phone, phone, password: pass, role: 'user' };
    const res = await apiPost('accounts', accounts);
    if(!res || !res.ok){ alert('Failed to create account'); return; }
    alert('Account created & logged in');
  } else {
    if(accounts[phone].password !== pass){ alert('Wrong password'); return; }
    alert('Logged in');
  }
  currentUser = accounts[phone];
  hideLogin();
  updateUserUI();
  await loadItems();
}
function logout(){ currentUser = null; adminUnlocked = false; adminUser = null; updateUserUI(); document.getElementById('adminPanel').style.display='none'; document.getElementById('adminUnlocked').style.display='none'; loadItems(); }
async function adminLogin(){
  const user = document.getElementById("adminUser").value.trim();
  const pass = document.getElementById("adminPass").value;
  if(!user || !pass){ alert('Enter both fields'); return; }
  try{
    const r = await fetchFile('shopping-site/admins.txt');
    if(!r || !r.ok){ alert('Cannot access admins.txt'); return; }
    const text = await r.text();
    const lines = text.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
    let ok = false;
    for(const line of lines){
      const parts = line.split(':');
      if(parts.length >= 2){
        const u = parts.shift();
        const p = parts.join(':');
        if(u===user && p===pass){ ok = true; break; }
      }
    }
    if(ok){
      adminUser = user; adminUnlocked = true;
      document.getElementById('adminPanel').style.display='block';
      document.getElementById('adminUnlocked').style.display='block';
      hideAdminLogin();
      alert('Admin authenticated');
      await logAdmin('Logged in');
      await loadItems();
    } else alert('Invalid admin credentials');
  }catch(e){ console.error('adminLogin error', e); alert('Failed to verify admin credentials'); }
}

// ==== items ====
async function loadItems(){
  const items = await apiGet('items');
  itemList.innerHTML = '';
  if(!items || Object.keys(items).length === 0){
    itemList.innerHTML = '<small>No items available.</small>';
  } else {
    for(const it of Object.values(items)){
      const el = document.createElement('div');
      el.className = 'item';
      const priceNum = (typeof it.price === 'number') ? it.price : parseFloat(it.price || 0);
      const priceStr = Number.isFinite(priceNum) ? priceNum.toFixed(2) : '0.00';
      el.innerHTML = `<strong>${escapeHtml(it.title)}</strong> â€” â‚¹${priceStr}<br/>
                      <div style="margin-top:6px">${escapeHtml(it.desc || '')}</div>
                      <div style="margin-top:8px">Stock: ${Number(it.stock || 0)}</div>
                      <div style="margin-top:8px">
                        <button ${!currentUser || (Number(it.stock||0) <= 0) ? 'disabled' : ''} data-id="${escapeHtml(it.id)}">Add to Cart</button>
                      </div>`;
      const btn = el.querySelector('button');
      btn.addEventListener('click', ()=> addToCart(String(it.id)));
      itemList.appendChild(el);
    }
  }
  if(adminUnlocked) renderAdminList(items);
  updateCartUI();
}

async function saveItem(){
  if(!adminUnlocked || !adminUser){ alert('Admin required'); return; }
  const idInput = document.getElementById('itemId').value.trim();
  const title = document.getElementById('itemTitle').value.trim();
  const price = parseFloat(document.getElementById('itemPrice').value.trim() || '0');
  const stock = parseInt(document.getElementById('itemStock').value.trim() || '0');
  const desc = document.getElementById('itemDesc').value.trim();
  if(!title){ alert('Title required'); return; }

  let data = await apiGet('items');
  if(!data || typeof data !== 'object') data = {};
  const id = idInput || String(Date.now());
  const isUpdate = Object.prototype.hasOwnProperty.call(data, id);
  data[id] = { id, title, price, stock, desc };

  const res = await apiPost('items', data);
  if(!res || !res.ok){ alert('Failed to save item on server. See console.'); console.error('saveItem apiPost response:', res); return; }
  await logAdmin(`${isUpdate ? 'Edited' : 'Saved'} item "${title}" (id:${id})`);
  alert('Item saved.');
  document.getElementById('itemId').value=''; document.getElementById('itemTitle').value=''; document.getElementById('itemPrice').value=''; document.getElementById('itemStock').value=''; document.getElementById('itemDesc').value='';
  await loadItems();
}

function renderAdminList(items){
  const list = document.getElementById('adminItemList');
  list.innerHTML = '';
  if(!items || Object.keys(items).length === 0){ list.innerHTML = '<small>No items</small>'; return; }
  for(const it of Object.values(items)){
    const id = String(it.id);
    const d = document.createElement('div');
    d.className = 'adminItem';
    const left = document.createElement('div');
    left.innerHTML = `<strong>${escapeHtml(it.title)}</strong> â€” â‚¹${(Number(it.price)||0).toFixed(2)} (stock: ${Number(it.stock||0)})`;
    const controls = document.createElement('div');
    controls.className = 'admin-controls';
    const editBtn = document.createElement('button'); editBtn.textContent = 'Edit';
    const delBtn = document.createElement('button'); delBtn.textContent = 'Delete';
    editBtn.addEventListener('click', async ()=>{ const data = await apiGet('items'); if(!data || !data[id]){ alert('Item not found on server'); await loadItems(); return; } editItemPopulate(id, data[id]); });
    delBtn.addEventListener('click', async ()=> deleteItem(id));
    controls.appendChild(editBtn); controls.appendChild(delBtn);
    d.appendChild(left); d.appendChild(controls);
    list.appendChild(d);
  }
}

function editItemPopulate(id, item){
  if(!adminUnlocked || !adminUser){ alert('Admin required'); return; }
  document.getElementById('itemId').value = id;
  document.getElementById('itemTitle').value = item.title || '';
  document.getElementById('itemPrice').value = (typeof item.price === 'number') ? item.price : (item.price || '');
  document.getElementById('itemStock').value = item.stock || 0;
  document.getElementById('itemDesc').value = item.desc || '';
  document.getElementById('itemTitle').scrollIntoView({behavior:'smooth', block:'center'});
}

async function deleteItem(id){
  if(!adminUnlocked || !adminUser){ alert('Admin required'); return; }
  id = String(id);
  let data = await apiGet('items');
  if(!data || typeof data !== 'object'){ alert('No items data on server'); return; }
  if(!Object.prototype.hasOwnProperty.call(data, id)){ alert('Item not found: ' + id); await loadItems(); return; }
  const title = data[id].title || id;
  if(!confirm(`Delete item "${title}"? This cannot be undone.`)) return;
  delete data[id];
  const res = await apiPost('items', data);
  if(!res || !res.ok){ console.error('Failed to save updated items after delete:', res); alert('Failed to delete item on server. See console.'); await loadItems(); return; }
  await logAdmin(`Deleted item "${title}" (id:${id})`);
  await loadItems();
}

// ==== admin log view ====
async function viewAdminLog(){
  if(!adminUnlocked || !adminUser){ alert('Admin required'); return; }
  try{
    const res = await fetchFile('shopping-site/admin_log.txt');
    const view = document.getElementById('adminLogView');
    if(!res || !res.ok){ view.textContent = '(no log yet)'; view.style.display = 'block'; return; }
    const txt = await res.text();
    view.textContent = txt || '(no log entries)';
    view.style.display = 'block';
  }catch(e){ console.error('viewAdminLog error', e); alert('Failed to load admin log'); }
}

// ==== orders view / helpers ====
async function viewOrders(){
  if(!adminUnlocked || !adminUser){ alert('Admin required'); return; }
  const listEl = document.getElementById('ordersList');
  const viewEl = document.getElementById('ordersView');
  const filter = document.getElementById('ordersFilter').value;
  listEl.innerHTML = '<small>Loading ordersâ€¦</small>';
  viewEl.style.display = 'none';
  try{
    let filesRaw = await listFilesWithPrefix('shopping-site/orders/');
    if(!filesRaw || filesRaw.length === 0){ listEl.innerHTML = '<small>No orders found</small>'; return; }
    const files = filesRaw.map(f => f.replace(/^\/+|\/+$/g,''));
    files.sort((a,b)=>{
      const ra = a.match(/order(\d+)\.txt$/i);
      const rb = b.match(/order(\d+)\.txt$/i);
      const na = ra ? parseInt(ra[1].replace(/^0+/, '') || 0,10) : 0;
      const nb = rb ? parseInt(rb[1].replace(/^0+/, '') || 0,10) : 0;
      return nb - na;
    });
    listEl.innerHTML = '';
    for(const f of files){
      let status = 'pending';
      let content = '';
      try{
        const res = await fetchFile(f);
        if(res && res.ok){
          content = await res.text();
          if(/STATUS:\s*DONE/i.test(content)) status='done';
          if(/DELETED by/i.test(content)) status='deleted';
        } else { console.warn('Cannot read order:', f, res && res.status); }
      }catch(e){ console.error('Error reading order', f, e); }
      if(filter === 'done' && status !== 'done') continue;
      if(filter === 'pending' && status !== 'pending') continue;
      if(filter === 'deleted' && status !== 'deleted') continue;

      const row = document.createElement('div'); row.className = 'order-row';
      const name = f.split('/').pop();
      const left = document.createElement('div');
      left.innerHTML = `<strong>${escapeHtml(name)}</strong><div class="muted" style="font-size:12px">${escapeHtml(f)}</div>`;
      const right = document.createElement('div');
      const badge = document.createElement('span');
      badge.className = 'badge ' + (status==='done' ? 'badge-done' : status==='deleted' ? 'badge-deleted' : '');
      badge.textContent = status.toUpperCase();
      const actions = document.createElement('div'); actions.className = 'order-actions';
      const viewBtn = document.createElement('button'); viewBtn.textContent = 'View';
      viewBtn.onclick = async ()=> {
        try{
          const r = await fetchFile(f);
          if(!r || !r.ok){ alert(`Cannot read order: server returned ${r ? r.status : '(no response)'}`); return; }
          const txt = await r.text();
          viewEl.textContent = txt;
          viewEl.style.display = 'block';
        }catch(e){ console.error('view order error', f, e); alert('Failed to fetch order file. See console.'); }
      };
      const doneBtn = document.createElement('button'); doneBtn.textContent = 'Mark Done';
      doneBtn.onclick = async ()=> {
        if(status==='done'){ alert('Order already marked done'); return; }
        if(!confirm('Mark this order as DONE?')) return;
        try{
          const r = await fetchFile(f);
          if(!r || !r.ok){ alert('Cannot read order to mark done'); return; }
          let txt = await r.text();
          txt += `\n\nSTATUS: DONE by ${adminUser} at ${timeNow()}\n`;
          const blob = new Blob([txt], { type:'text/plain' });
          const up = await uploadFile(f, blob);
          if(!up || !up.ok){ alert('Failed to write DONE marker. See console.'); return; }
          await logAdmin(`Marked order ${name} as DONE`);
          alert('Order marked done');
          await viewOrders();
        }catch(e){ console.error('markDone exception', f, e); alert('Failed to mark done. See console.'); }
      };
      const delBtn = document.createElement('button'); delBtn.textContent = 'Delete';
      delBtn.onclick = async ()=> {
        if(!confirm('Overwrite order file with DELETED marker?')) return;
        try{
          const txt = `DELETED by ${adminUser} at ${timeNow()}\n`;
          const blob = new Blob([txt], { type:'text/plain' });
          const up = await uploadFile(f, blob);
          if(!up || !up.ok){ alert('Failed to write delete marker. See console.'); return; }
          await logAdmin(`Deleted order ${name}`);
          alert('Order deleted (overwritten)');
          await viewOrders();
        }catch(e){ console.error('deleteOrder exception', f, e); alert('Failed to delete order. See console.'); }
      };
      actions.append(viewBtn, doneBtn, delBtn);
      right.append(badge, actions);
      row.append(left, right);
      listEl.appendChild(row);
    }
  }catch(e){ console.error('viewOrders main error', e); listEl.innerHTML = '<small>Error loading orders</small>'; }
}

// get next order number by scanning existing order files; returns numeric
async function getNextOrderNumber(){
  try{
    const files = await listFilesWithPrefix('shopping-site/orders/');
    let maxNum = 0;
    const re = /order(\d+)\.txt$/i;
    for(const fRaw of files){
      const f = fRaw.replace(/^\/+|\/+$/g,'');
      const m = f.match(re);
      if(m && m[1]){
        // safe digit-by-digit parse (avoid float rounding on huge numbers)
        const digits = m[1];
        let val = 0;
        for(let i=0;i<digits.length;i++){
          const d = digits.charCodeAt(i) - 48;
          if(d>=0 && d<=9) val = val*10 + d;
        }
        if(val > maxNum) maxNum = val;
      }
    }
    return maxNum + 1;
  }catch(e){ console.error('getNextOrderNumber error', e); return Date.now(); }
}

// ==== cart ====
function addToCart(id){
  cart[id] = (cart[id] || 0) + 1;
  updateCartUI();
}
async function updateCartUI(){
  // show human readable cart (title + qty + price)
  cartList.innerHTML = '';
  let total = 0;
  const items = await apiGet('items');
  for(const [id, qty] of Object.entries(cart)){
    const li = document.createElement('li');
    const it = items && items[id];
    const title = it ? (it.title || id) : id;
    const price = it ? Number(it.price || 0) : 0;
    total += price * qty;
    li.textContent = `${title} Ã— ${qty} â€” â‚¹${(price * qty).toFixed(2)}`;
    cartList.appendChild(li);
  }
  cartTotal.textContent = `Total: â‚¹${Number(total).toFixed(2)}`;
}

// place order with reservation and rollback logic
async function placeOrder(){
  if(!currentUser){ alert('Please login first'); return; }
  // 1) read items
  const origItems = await apiGet('items');
  if(!origItems || Object.keys(origItems).length === 0){ alert('No items on server'); return; }
  // 2) validate and prepare newItems
  const newItems = JSON.parse(JSON.stringify(origItems));
  let lines = [];
  let totalCents = 0;
  for(const [id, qty] of Object.entries(cart)){
    const it = newItems[id];
    if(!it){ alert('Item not found: ' + id); return; }
    const stock = Number(it.stock || 0);
    const price = Number(it.price || 0);
    if(stock < qty){ alert(`Not enough stock for "${it.title || id}"`); return; }
    const unitCents = Math.round(price * 100);
    totalCents += unitCents * qty;
    lines.push({ title: it.title || id, qty, unitPrice: price });
    newItems[id].stock = stock - qty;
  }
  // 3) reserve stock (save updated items)
  const saveRes = await apiPost('items', newItems);
  if(!saveRes || !saveRes.ok){
    console.error('Failed to update item stock before placing order:', saveRes);
    alert('Failed to reserve stock on server. Order aborted. See console.');
    return;
  }
  // 4) build order text + filename
  const orderNum = await getNextOrderNumber();
  const filenamePrimary = `shopping-site/orders/order${orderNum}.txt`;
  const filenameFallback = `shopping-site/order${orderNum}.txt`;
  const isoTime = new Date().toISOString();
  let orderText = `Order: ${orderNum}\nTime: ${isoTime}\nName: ${currentUser.name}\nPhone: ${currentUser.phone}\n\nItems:\n`;
  for(const li of lines) orderText += `- ${li.title} x${li.qty} @ ${Number(li.unitPrice).toFixed(2)}\n`;
  orderText += `\nTotal: â‚¹${(totalCents/100).toFixed(2)}\n`;
  const blob = new Blob([orderText], { type: 'text/plain' });
  // 5) attempt primary upload then fallback
  try{
    let up = await uploadFile(filenamePrimary, blob);
    if(up && up.ok){
      cart = {}; updateCartUI();
      alert(`Order placed: ${filenamePrimary}`);
      return;
    }
    const body1 = up ? (await up.text().catch(()=>'(no body)')) : '(no response)';
    console.warn('Primary upload failed', up && up.status, body1);
    // fallback
    let up2 = await uploadFile(filenameFallback, blob);
    if(up2 && up2.ok){
      cart = {}; updateCartUI();
      alert(`Order placed (fallback): ${filenameFallback}`);
      return;
    }
    const body2 = up2 ? (await up2.text().catch(()=>'(no body)')) : '(no response)';
    console.error('Both uploads failed', { primary: up && up.status, body1, fallback: up2 && up2.status, body2 });
    // rollback
    const rollback = await apiPost('items', origItems);
    if(!rollback || !rollback.ok){
      console.error('Rollback failed â€” items state may be inconsistent.', rollback);
      alert('Order failed to save and rollback failed. Check server logs; items may be inconsistent.');
    } else {
      alert(`Failed to save order file on server.\nPrimary: ${up ? up.status : '(no response)'} ${body1}\nFallback: ${up2 ? up2.status : '(no response)'} ${body2}\nStock changes rolled back.`);
    }
    return;
  }catch(err){
    console.error('Upload exception', err);
    const rollback = await apiPost('items', origItems);
    if(!rollback || !rollback.ok){
      console.error('Rollback failed after exception', rollback);
      alert('Order failed due to upload error and rollback failed. See console.');
    } else {
      alert('Order failed due to upload error; stock changes rolled back. See console for details.');
    }
    return;
  }
}

// ==== UI wiring ====
function showLogin(){ document.getElementById('loginModal').style.display = 'block'; }
function hideLogin(){ document.getElementById('loginModal').style.display = 'none'; }
function showAdminLogin(){ document.getElementById('adminModal').style.display = 'block'; }
function hideAdminLogin(){ document.getElementById('adminModal').style.display = 'none'; }
function updateUserUI(){ document.getElementById('userInfo').textContent = currentUser ? currentUser.name : 'Guest'; document.getElementById('loginBtn').style.display = currentUser ? 'none' : 'inline'; document.getElementById('logoutBtn').style.display = currentUser ? 'inline' : 'none'; }

document.getElementById('loginBtn').onclick = showLogin;
document.getElementById('closeModal').onclick = hideLogin;
document.getElementById('loginSubmit').onclick = loginOrRegister;
document.getElementById('logoutBtn').onclick = logout;
document.getElementById('placeOrderBtn').onclick = placeOrder;
document.getElementById('adminLoginBtn').onclick = showAdminLogin;
document.getElementById('closeAdminModal').onclick = hideAdminLogin;
document.getElementById('adminLoginSubmit').onclick = adminLogin;
document.getElementById('saveItemBtn').onclick = saveItem;
document.getElementById('clearEditBtn').onclick = ()=>{ document.getElementById('itemId').value=''; document.getElementById('itemTitle').value=''; document.getElementById('itemPrice').value=''; document.getElementById('itemStock').value=''; document.getElementById('itemDesc').value=''; };
document.getElementById('viewLogsBtn').onclick = viewAdminLog;
document.getElementById('viewOrdersBtn').onclick = viewOrders;
document.getElementById('ordersFilter').onchange = viewOrders;

// ==== startup ====
(async function init(){
  baseUrl = await resolveServer();
  showStatus('Server: ' + (baseUrl || 'unknown'), !!baseUrl);
  try{
    const r = await fetch(`${baseUrl}/room/default?key=${encodeURIComponent(serverKey)}`);
    if(r.ok){ showStatus('Connected âœ“', true); await loadItems(); }
    else showStatus('Key invalid or server error âœ—', false);
  }catch(e){ showStatus('Server unreachable âœ—', false); console.error(e); }
})();
</script>
</body>
</html>
