<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Shop — Full Standalone</title>
  <style>
    :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial; --accent:#2563eb}
    body{margin:18px;background:#f3f6fb;color:#111}
    header{display:flex;align-items:center;justify-content:space-between;gap:12px}
    h1{font-size:20px;margin:0}
    .btn{padding:8px 10px;border-radius:6px;border:1px solid rgba(0,0,0,0.08);background:#fff;cursor:pointer}
    .btn-primary{background:var(--accent);color:#fff;border:none}
    main{display:grid;grid-template-columns:1fr 340px;gap:18px;margin-top:18px}
    .panel{background:#fff;padding:12px;border-radius:10px;box-shadow:0 1px 0 rgba(0,0,0,0.03)}
    #products{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:12px}
    .card{padding:12px;border-radius:8px;background:linear-gradient(180deg,#fff,#fbfdff);display:flex;flex-direction:column;gap:8px}
    .card .title{font-weight:700}
    .card .price{font-family:monospace}
    .card .meta{font-size:12px;color:#555}
    .card .actions{margin-top:auto;display:flex;gap:6px;justify-content:flex-end}
    #cartItems{display:flex;flex-direction:column;gap:8px}
    .cart-row{display:flex;gap:8px;align-items:center;justify-content:space-between}
    .small{font-size:12px;color:#666}
    .muted{color:#777}
    label{display:block;font-size:13px;margin-bottom:6px}
    input[type="text"], input[type="number"], textarea{width:100%;padding:8px;border-radius:6px;border:1px solid #ddd}
    .modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.35)}
    .modal .panel{width:720px;max-width:96%}
    .hidden{display:none}
    .errmsg{color:#b71c1c}
    .okmsg{color:#056f00}
    .list-inline{display:flex;gap:8px;flex-wrap:wrap}
    footer{margin-top:18px;font-size:13px;color:#555}
    pre{background:#0b1220;color:#bcd;font-size:13px;padding:8px;border-radius:6px;overflow:auto}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Standalone Shop</h1>
      <div class="small">Connects to backend at <span id="serverUrlDisplay">http://localhost:8080</span> (reads <code>tunnel.txt</code> if present)</div>
    </div>
    <div class="list-inline">
      <button class="btn" id="refreshBtn">Refresh Data</button>
      <button class="btn" id="viewOrdersBtn">View Orders</button>
      <button class="btn" id="retryFailedBtn">Retry Failed Orders</button>
    </div>
  </header>

  <main>
    <section class="panel">
      <div style="display:flex;align-items:center;justify-content:space-between">
        <strong>Products</strong>
        <div class="small muted">Edit / Delete update local copy or call API when available</div>
      </div>

      <div id="products" style="margin-top:12px">
        <!-- product cards will render here -->
      </div>

      <hr style="margin:14px 0" />

      <div style="display:flex;gap:8px;align-items:center;">
        <button class="btn btn-primary" id="newItemBtn">New Item</button>
        <div class="small muted">Edits may be sent to <code>/api/items</code> if available; otherwise stored locally.</div>
      </div>
    </section>

    <aside class="panel">
      <strong>Cart</strong>
      <div id="cartItems" style="margin-top:8px"></div>
      <div style="display:flex;justify-content:space-between;align-items:center;margin-top:12px">
        <div class="small">Total: <span id="cartTotal">0.00</span></div>
        <button class="btn btn-primary" id="checkoutBtn">Place Order</button>
      </div>

      <hr style="margin:12px 0" />
      <div>
        <strong>Status</strong>
        <div id="status" class="small" style="margin-top:6px;">Ready</div>
      </div>

      <hr style="margin:12px 0" />
      <div>
        <strong>Orders (Preview)</strong>
        <div id="ordersPreview" class="small muted" style="margin-top:8px">Click "View Orders" to load.</div>
      </div>
    </aside>
  </main>

  <footer>
    <div class="small">Notes: The page tries multiple fallbacks (API → static files → localStorage). Edit/delete actions first attempt standard REST endpoints and gracefully degrade when unavailable.</div>
  </footer>

  <!-- Edit / New Item Modal -->
  <div id="itemModal" class="modal hidden" aria-hidden="true">
    <div class="panel">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong id="modalTitle">New Item</strong>
        <div><button class="btn" id="closeModalBtn">Close</button></div>
      </div>
      <div style="margin-top:12px">
        <label>Title<input id="itemTitle" type="text" /></label>
        <label>Description<textarea id="itemDesc" rows="3"></textarea></label>
        <label>Price<input id="itemPrice" type="number" step="0.01" /></label>
        <label>Image URL (optional)<input id="itemImage" type="text" /></label>
        <div style="display:flex;gap:8px;margin-top:8px">
          <button class="btn btn-primary" id="saveItemBtn">Save Item</button>
          <button class="btn" id="cancelItemBtn">Cancel</button>
        </div>
        <div id="itemModalMsg" class="small" style="margin-top:8px"></div>
      </div>
    </div>
  </div>

  <!-- Orders Viewer Modal -->
  <div id="ordersModal" class="modal hidden" aria-hidden="true">
    <div class="panel" style="max-height:80vh;overflow:auto">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <strong>Orders</strong>
        <div><button class="btn" id="closeOrdersBtn">Close</button></div>
      </div>
      <div id="ordersList" style="margin-top:12px"></div>
    </div>
  </div>

<script>
/*
  shop.html
  - Reads server URL from tunnel.txt (if present), else uses http://localhost:8080
  - Loads items from server: tries API (/api/items), then /items.json, then localStorage fallback
  - Allows Add/Edit/Delete: uses API endpoints if available; otherwise modifies local copy and saves to localStorage
  - Cart + Place Order: tries POST /api/orders, then tries POST to /orders/order<ID>.txt (text fallback), then saves failed orders locally for retry
  - View Orders: tries /api/orders, then /orders/index.json, then probes /orders/orderN.txt (HEAD) up to a configurable limit
*/

const DEFAULT_SERVER = 'http://localhost:8080';
const TUNNEL_TXT = 'tunnel.txt';
const ITEMS_JSON = '/items.json';
const API_ITEMS = '/api/items';
const API_ORDERS = '/api/orders';
const ORDERS_FOLDER = '/orders';
const PROBE_MAX = 100;

let SERVER_URL = DEFAULT_SERVER;
const serverUrlDisplay = document.getElementById('serverUrlDisplay');
const productsEl = document.getElementById('products');
const statusEl = document.getElementById('status');
const cartItemsEl = document.getElementById('cartItems');
const cartTotalEl = document.getElementById('cartTotal');
const ordersPreviewEl = document.getElementById('ordersPreview');
const ordersListEl = document.getElementById('ordersList');

const refreshBtn = document.getElementById('refreshBtn');
const viewOrdersBtn = document.getElementById('viewOrdersBtn');
const retryFailedBtn = document.getElementById('retryFailedBtn');

const itemModal = document.getElementById('itemModal');
const modalTitle = document.getElementById('modalTitle');
const itemTitle = document.getElementById('itemTitle');
const itemDesc = document.getElementById('itemDesc');
const itemPrice = document.getElementById('itemPrice');
const itemImage = document.getElementById('itemImage');
const saveItemBtn = document.getElementById('saveItemBtn');
const closeModalBtn = document.getElementById('closeModalBtn');
const cancelItemBtn = document.getElementById('cancelItemBtn');
const itemModalMsg = document.getElementById('itemModalMsg');
const newItemBtn = document.getElementById('newItemBtn');

const ordersModal = document.getElementById('ordersModal');
const closeOrdersBtn = document.getElementById('closeOrdersBtn');

let items = [];        // current in-memory items
let cart = {};         // { itemId: qty }
let editingItemId = null;

const localItemsKey = 'shop_items_v1';
const failedOrdersKey = 'shop_failed_orders_v1';

// init
(async function init(){
  SERVER_URL = await getServerUrl();
  serverUrlDisplay.textContent = SERVER_URL;
  attachEventListeners();
  await loadItemsAndRender();
  renderCart();
})();

function attachEventListeners(){
  refreshBtn.addEventListener('click', async ()=> {
    setStatus('Refreshing...');
    await loadItemsAndRender(true);
    setStatus('Refreshed');
  });

  newItemBtn.addEventListener('click', ()=> openItemModal());
  closeModalBtn.addEventListener('click', closeItemModal);
  cancelItemBtn.addEventListener('click', closeItemModal);
  saveItemBtn.addEventListener('click', saveItemFromModal);

  checkoutBtn = document.getElementById('checkoutBtn');
  checkoutBtn.addEventListener('click', placeOrder);

  viewOrdersBtn.addEventListener('click', async ()=> {
    ordersModal.classList.remove('hidden');
    ordersModal.setAttribute('aria-hidden','false');
    await viewOrders();
  });
  closeOrdersBtn.addEventListener('click', ()=> {
    ordersModal.classList.add('hidden');
    ordersModal.setAttribute('aria-hidden','true');
  });

  retryFailedBtn.addEventListener('click', ()=> retryFailedOrders());
  window.addEventListener('keydown', (e)=> {
    if (e.key === 'Escape') {
      closeItemModal();
      ordersModal.classList.add('hidden');
    }
  });
}

function setStatus(msg, isError=false){
  statusEl.textContent = msg;
  statusEl.className = isError ? 'small errmsg' : 'small';
}

// read tunnel.txt if exists
async function getServerUrl(){
  try {
    const res = await fetch(TUNNEL_TXT, {cache:'no-store'});
    if (!res.ok) return DEFAULT_SERVER;
    const txt = (await res.text()).trim();
    if (!txt) return DEFAULT_SERVER;
    // allow full URL or path
    return txt.startsWith('http') ? txt.replace(/\/$/,'') : txt.replace(/\/$/,'');
  } catch(e){
    // network error or file missing -> fallback
    return DEFAULT_SERVER;
  }
}

/* ---------- Items loading / saving ---------- */

async function loadItemsAndRender(forceApi=false){
  // 1) try API
  if (!forceApi){
    const api = await tryApiGetItems();
    if (api) { items = api; renderProducts(); return; }
  }

  // 2) try static items.json at root of server
  try {
    const res = await fetch(`${SERVER_URL}${ITEMS_JSON}`, {cache:'no-store'});
    if (res.ok) {
      const json = await res.json();
      if (Array.isArray(json)) { items = json; saveLocalItemsCopy(); renderProducts(); return; }
    }
  } catch(e){ /* ignore */ }

  // 3) local storage fallback
  const local = localStorage.getItem(localItemsKey);
  if (local){
    try { items = JSON.parse(local); renderProducts(); return; } catch(e){}
  }

  // 4) bundled default items
  items = [
    { id: generateId(), title: 'Example Widget', price: 9.99, description: 'A sample product', image: '' },
    { id: generateId(), title: 'Sample Pack', price: 19.5, description: 'Two for the price of one', image: '' }
  ];
  saveLocalItemsCopy();
  renderProducts();
}

async function tryApiGetItems(){
  try {
    const res = await fetch(`${SERVER_URL}${API_ITEMS}`, {cache:'no-store'});
    if (!res.ok) return null;
    const json = await res.json();
    if (Array.isArray(json)) return json;
    if (Array.isArray(json.items)) return json.items;
    return null;
  } catch(e){ return null; }
}

function saveLocalItemsCopy(){
  try { localStorage.setItem(localItemsKey, JSON.stringify(items)); } catch(e){}
}

/* ---------- Render products ---------- */

function renderProducts(){
  productsEl.innerHTML = '';
  if (!items || items.length === 0){
    productsEl.innerHTML = '<div class="small muted">No products available.</div>';
    return;
  }
  items.forEach(it => {
    const card = document.createElement('div');
    card.className = 'card';
    const img = document.createElement('div');
    img.style.minHeight = '60px';
    img.style.display = 'flex';
    img.style.alignItems = 'center';
    img.style.justifyContent = 'center';
    if (it.image){
      const im = document.createElement('img');
      im.src = it.image; im.alt = it.title; im.style.maxWidth='100%'; im.style.maxHeight='80px';
      img.appendChild(im);
    } else {
      img.textContent = 'Image';
      img.className = 'small muted';
      img.style.border='1px dashed #e6eefc'; img.style.borderRadius='6px';
      img.style.padding='8px';
    }
    const title = document.createElement('div'); title.className = 'title'; title.textContent = it.title;
    const desc = document.createElement('div'); desc.className = 'meta'; desc.textContent = it.description || '';
    const price = document.createElement('div'); price.className = 'price'; price.textContent = `₹ ${Number(it.price).toFixed(2)}`;

    const actions = document.createElement('div'); actions.className = 'actions';
    const addBtn = document.createElement('button'); addBtn.className='btn'; addBtn.textContent='Add';
    addBtn.addEventListener('click', ()=> addToCart(it.id));
    const editBtn = document.createElement('button'); editBtn.className='btn'; editBtn.textContent='Edit';
    editBtn.addEventListener('click', ()=> openItemModal(it.id));
    const delBtn = document.createElement('button'); delBtn.className='btn'; delBtn.textContent='Delete';
    delBtn.addEventListener('click', ()=> deleteItem(it.id, card));

    actions.appendChild(addBtn);
    actions.appendChild(editBtn);
    actions.appendChild(delBtn);

    card.appendChild(img);
    card.appendChild(title);
    card.appendChild(desc);
    card.appendChild(price);
    card.appendChild(actions);
    productsEl.appendChild(card);
  });
}

/* ---------- Cart ---------- */

function addToCart(itemId){
  cart[itemId] = (cart[itemId] || 0) + 1;
  renderCart();
  setStatus('Added to cart');
}

function renderCart(){
  cartItemsEl.innerHTML = '';
  let total = 0;
  const rows = [];
  for (const id of Object.keys(cart)){
    const qty = cart[id];
    const it = items.find(x=>x.id===id);
    if (!it) continue;
    total += (Number(it.price) || 0) * qty;

    const row = document.createElement('div'); row.className='cart-row';
    const left = document.createElement('div'); left.textContent = `${it.title} × ${qty}`;
    const right = document.createElement('div'); 
    const minus = document.createElement('button'); minus.className='btn'; minus.textContent='−';
    minus.addEventListener('click', ()=> { changeQty(id, Math.max(0, qty-1)); });
    const plus = document.createElement('button'); plus.className='btn'; plus.textContent='+';
    plus.addEventListener('click', ()=> { changeQty(id, qty+1); });
    const remove = document.createElement('button'); remove.className='btn'; remove.textContent='Remove';
    remove.addEventListener('click', ()=> { changeQty(id, 0); });
    right.appendChild(minus); right.appendChild(plus); right.appendChild(remove);
    row.appendChild(left); row.appendChild(right);
    cartItemsEl.appendChild(row);
  }
  cartTotalEl.textContent = Number(total).toFixed(2);
}

function changeQty(id, qty){
  if (qty <= 0) delete cart[id];
  else cart[id] = qty;
  renderCart();
}

/* ---------- Item modal (add/edit) ---------- */

function openItemModal(id=null){
  editingItemId = id;
  if (id){
    modalTitle.textContent = 'Edit Item';
    const it = items.find(x=>x.id===id);
    if (!it) { setStatus('Item not found', true); return; }
    itemTitle.value = it.title || '';
    itemDesc.value = it.description || '';
    itemPrice.value = Number(it.price || 0);
    itemImage.value = it.image || '';
  } else {
    modalTitle.textContent = 'New Item';
    itemTitle.value = ''; itemDesc.value=''; itemPrice.value=''; itemImage.value='';
  }
  itemModal.classList.remove('hidden');
  itemModal.setAttribute('aria-hidden','false');
}

function closeItemModal(){
  itemModal.classList.add('hidden');
  itemModal.setAttribute('aria-hidden','true');
  itemModalMsg.textContent = '';
  editingItemId = null;
}

async function saveItemFromModal(){
  const title = itemTitle.value.trim();
  const desc = itemDesc.value.trim();
  const price = Number(itemPrice.value || 0);
  const image = itemImage.value.trim();
  if (!title) { itemModalMsg.textContent = 'Title required'; itemModalMsg.className='errmsg'; return; }

  if (editingItemId){
    // update existing
    const idx = items.findIndex(x=>x.id===editingItemId);
    if (idx === -1) { itemModalMsg.textContent='Item gone'; itemModalMsg.className='errmsg'; return; }
    items[idx] = { ...items[idx], title, description: desc, price, image };
    // try to update via API first
    const ok = await tryApiSaveItems(items);
    if (ok) { itemModalMsg.textContent='Saved to server'; itemModalMsg.className='okmsg'; closeItemModal(); renderProducts(); saveLocalItemsCopy(); return; }
    // fallback: save locally
    saveLocalItemsCopy();
    renderProducts();
    itemModalMsg.textContent='Saved locally (server unavailable)';
    itemModalMsg.className='small muted';
    setTimeout(closeItemModal, 800);
    return;
  } else {
    // new item
    const newItem = { id: generateId(), title, description: desc, price, image };
    items.push(newItem);
    const ok = await tryApiSaveItems(items);
    if (ok) { itemModalMsg.textContent='Saved to server'; itemModalMsg.className='okmsg'; closeItemModal(); renderProducts(); saveLocalItemsCopy(); return; }
    saveLocalItemsCopy();
    renderProducts();
    itemModalMsg.textContent='Saved locally (server unavailable)';
    itemModalMsg.className='small muted';
    setTimeout(closeItemModal, 800);
    return;
  }
}

// attempt to save items array via API (PUT or POST) - many servers won't accept this, but we try
async function tryApiSaveItems(arr){
  try {
    // Try a PUT to /api/items (server expected to implement it)
    const res = await fetch(`${SERVER_URL}${API_ITEMS}`, {
      method: 'PUT',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(arr)
    });
    if (res.ok) return true;
    // try POST as alternative
    const res2 = await fetch(`${SERVER_URL}${API_ITEMS}`, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(arr)
    });
    if (res2.ok) return true;
    return false;
  } catch(e){
    return false;
  }
}

async function deleteItem(id, cardEl){
  if (!confirm('Delete this item?')) return;
  // remove locally first
  const idx = items.findIndex(x=>x.id===id);
  if (idx === -1) { setStatus('Item not found', true); return; }
  const removed = items.splice(idx,1);
  renderProducts(); saveLocalItemsCopy();
  setStatus('Item removed locally');
  // try to delete via API
  try {
    const res = await fetch(`${SERVER_URL}${API_ITEMS}/${encodeURIComponent(id)}`, { method: 'DELETE' });
    if (res.ok) { setStatus('Item removed on server'); return; }
    // otherwise try saving full items array
    await tryApiSaveItems(items);
  } catch(e){}
}

/* ---------- Place order ---------- */

async function placeOrder(){
  if (Object.keys(cart).length === 0) { setStatus('Cart is empty', true); return; }
  const order = {
    id: 'order-' + Date.now(),
    created: new Date().toISOString(),
    items: [],
    total: Number(cartTotalEl.textContent) || 0
  };
  for (const id of Object.keys(cart)){
    const it = items.find(x=>x.id===id);
    if (!it) continue;
    order.items.push({ id: it.id, title: it.title, qty: cart[id], price: it.price });
  }

  setStatus('Placing order...');
  try {
    // Primary: try JSON API
    const res = await fetch(`${SERVER_URL}${API_ORDERS}`, {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify(order)
    });
    if (res.ok) {
      setStatus('Order placed successfully');
      cart = {}; renderCart();
      return;
    }
    // If API not available, try fallback: write a text file into /orders/ as order<ID>.txt
    const orderText = orderToText(order);
    const filename = `${order.id}.txt`;
    // try POST to /orders/filename (some servers accept such writes)
    const res2 = await fetch(`${SERVER_URL}${ORDERS_FOLDER}/${encodeURIComponent(filename)}`, {
      method: 'POST',
      headers: {'Content-Type':'text/plain'},
      body: orderText
    });
    if (res2.ok || res2.status === 201) {
      setStatus('Order saved to orders folder (server accepted write)');
      cart = {}; renderCart();
      return;
    }
    // If both attempts fail, store locally to retry
    stashFailedOrder(order);
    setStatus('Order could not be saved to server — kept locally and will retry when you click "Retry Failed Orders".', true);
  } catch(e){
    stashFailedOrder(order);
    setStatus('Network error while placing order — saved locally for retry: ' + e.message, true);
  }
}

function orderToText(order){
  const lines = [];
  lines.push(`Order ID: ${order.id}`);
  lines.push(`Created: ${order.created}`);
  lines.push('');
  lines.push('Items:');
  for (const it of order.items) lines.push(` - ${it.title} × ${it.qty} @ ${it.price}`);
  lines.push('');
  lines.push(`Total: ${order.total}`);
  return lines.join('\n');
}

function stashFailedOrder(order){
  const list = JSON.parse(localStorage.getItem(failedOrdersKey) || '[]');
  list.push(order);
  localStorage.setItem(failedOrdersKey, JSON.stringify(list));
}

/* ---------- Retry failed orders ---------- */

async function retryFailedOrders(){
  const list = JSON.parse(localStorage.getItem(failedOrdersKey) || '[]');
  if (!list || list.length === 0) { setStatus('No failed orders to retry'); return; }
  setStatus(`Retrying ${list.length} failed order(s)...`);
  const remaining = [];
  for (const order of list){
    try {
      const res = await fetch(`${SERVER_URL}${API_ORDERS}`, {
        method: 'POST',
        headers: {'Content-Type':'application/json'},
        body: JSON.stringify(order)
      });
      if (res.ok) {
        // ok
        continue;
      }
      // try orders folder text post
      const filename = `${order.id}.txt`;
      const res2 = await fetch(`${SERVER_URL}${ORDERS_FOLDER}/${encodeURIComponent(filename)}`, {
        method: 'POST',
        headers: {'Content-Type':'text/plain'},
        body: orderToText(order)
      });
      if (res2.ok || res2.status === 201) continue;
      // failed -> keep
      remaining.push(order);
    } catch(e){
      remaining.push(order);
    }
  }
  localStorage.setItem(failedOrdersKey, JSON.stringify(remaining));
  if (remaining.length === 0) {
    setStatus('All failed orders retried and sent successfully');
  } else {
    setStatus(`${remaining.length} order(s) still failed — saved locally`, true);
  }
}

/* ---------- View Orders (preview) ---------- */

async function viewOrders(){
  ordersListEl.innerHTML = 'Loading orders...';
  // 1) API
  try {
    const res = await fetch(`${SERVER_URL}${API_ORDERS}`, {cache:'no-store'});
    if (res.ok) {
      const json = await res.json();
      const files = Array.isArray(json) ? json : (Array.isArray(json.files) ? json.files : json.orders || []);
      renderOrdersList(files);
      return;
    }
  } catch(e){ /* ignore */ }

  // 2) try /orders/index.json
  try {
    const res2 = await fetch(`${SERVER_URL}${ORDERS_FOLDER}/index.json`, {cache:'no-store'});
    if (res2.ok){
      const json = await res2.json();
      const files = Array.isArray(json) ? json : (Array.isArray(json.files) ? json.files : []);
      renderOrdersList(files);
      return;
    }
  } catch(e){}

  // 3) fallback: probe order1..orderN with HEAD
  const found = [];
  for (let i=1;i<=PROBE_MAX;i++){
    const name = `order${i}.txt`;
    try {
      const res = await fetch(`${SERVER_URL}${ORDERS_FOLDER}/${encodeURIComponent(name)}`, { method: 'HEAD', cache: 'no-store' });
      if (res.ok) found.push(name);
    } catch(e){}
  }
  renderOrdersList(found);
}

function renderOrdersList(files){
  ordersListEl.innerHTML = '';
  if (!files || files.length === 0){
    ordersListEl.innerHTML = '<div class="small muted">No orders found.</div>';
    return;
  }
  files.forEach(fname => {
    const row = document.createElement('div');
    row.style.borderBottom = '1px solid #eee';
    row.style.padding = '8px 0';
    const a = document.createElement('a');
    a.href = `${SERVER_URL}${ORDERS_FOLDER}/${encodeURIComponent(fname)}`;
    a.textContent = fname;
    a.target = '_blank';
    row.appendChild(a);

    const viewBtn = document.createElement('button'); viewBtn.className='btn'; viewBtn.style.marginLeft='8px';
    viewBtn.textContent = 'Open';
    viewBtn.addEventListener('click', async ()=> {
      // open raw order content in modal
      try {
        const res = await fetch(`${SERVER_URL}${ORDERS_FOLDER}/${encodeURIComponent(fname)}`);
        if (!res.ok) { alert(`Cannot read order: ${fname} (${res.status})`); return; }
        const text = await res.text();
        alert(text); // quick view; you can replace with nicer UI
      } catch(e){ alert('Error: ' + e.message); }
    });
    row.appendChild(viewBtn);

    const delBtn = document.createElement('button'); delBtn.className='btn'; delBtn.style.marginLeft='6px';
    delBtn.textContent = 'Delete';
    delBtn.addEventListener('click', async ()=> {
      if (!confirm('Delete ' + fname + '?')) return;
      try {
        // try API delete
        const res = await fetch(`${SERVER_URL}${API_ORDERS}/${encodeURIComponent(fname)}`, { method: 'DELETE' });
        if (res.ok) { row.remove(); return; }
        // try DELETE on /orders/<file> (some servers permit)
        const res2 = await fetch(`${SERVER_URL}${ORDERS_FOLDER}/${encodeURIComponent(fname)}`, { method: 'DELETE' });
        if (res2.ok) { row.remove(); return; }
        alert('Delete failed (server did not support delete).');
      } catch(e){ alert('Delete failed: ' + e.message); }
    });
    row.appendChild(delBtn);

    ordersListEl.appendChild(row);
  });
}

/* ---------- Utilities ---------- */

function generateId(){
  // simple unique id
  return 'id_' + Math.random().toString(36).slice(2,9);
}
</script>
</body>
</html>
